let prom;
prom='<table><td id="lev">'
+'<ol><h3>начнём разгром шведа под Полтавой</h3>'
+'<li><i>Асинхронная функция:</i><br>'
+'setTimeout(function greet() {<br>'
  +'alert("Выполннение происходит по истечении 5 секунд")<br>'
+'}, 5000) <i>//прошло 5 секунд и функция выполнилась</i><br>'
+'alert("А в эти пять секунд мы ещё много гадостей наделали");<br>'
+'<i>//Пока не загрузился код, мы можем заниматься чем-то другим</i><br>'
+'<a>Посмотрим как ведёт себя долбанный стек:</a><br>'
+'function main(){<br>'
	+'setTimeout(function greet(){<br>'
		+'alert("kommen")<br>'
	+'},2000)<br>'
	+'alert("willkommen")<br>'
+'}<br>'
+'main() <i>//сначала вывелась внутрення команда, затем внешняя(задержки не было)</i><br>'
+'<i>//просто вызовем main()</i><br>'
+'main(); <i>//! вызвали и получили задержку</i><br>'
+'<i>А со стеком всё в порядке, ему плевать на код, работает как ему надо</i><br>'
+'</li><li><a>Стек вызовов</a><br>'
+'<a>стек -структура данных, где последний попавший в систему элемент '
+'извлекатеся оттуда первым номером</a><br>'
+'function outer(){<br>'
	+'function inner(){<br>'
		+'<i>//функия 3</i><br>'
		+'alert("Hello!") //Только она и выскочила. Или оно</i><br>'
	+'}<br>'
	+'<i>//функция 2</i><br>'
	+'inner()<br>'
+'}<br>'
+'<i>//и функция 1</i><br>'
+'outer()<br>'
+'<br><a>Заценим ассинхронный код</a><br>'
+'function main(){<br>'
	+'setTimeout(function greet(){<br>'
		+'alert("Hello!")<br>'
	+'},2000) <i>//2 секунды задержка</i><br>'
	+'alert("Bye!")<br>'
+'}<br>'
+'main() <i>//Bye. Hello (стек)</i><br>'
+'setTimeout(()=>{<br>'
	+'setTimeout(()=>{<br>'
		+'setTimeout(()=>{<br>'
		+'	setTimeout(()=>{<br>'
				+'alert("Hello")<br>'
			+'},2000)<br>'
		+'	},2000)<br>'
	+'		},2000)<br>'
+'			},2000) <i>//вывела через восемь секунд hello</i><br>'
+'<a>Это всё глупости. В таких случаях используем промисы(Primiese)</a><br>'
+'const promise1=new Promise((resolve,reject)=>{<br>'
  +' setTimeout(()=>{<br>'
+'resolve("mrak");<br>'
  +' },3000);<br>'
+'});<br>'
+'promise1.then((value)=>{<br>'
  +' 	alert(value); <i>//expected "mrak"(хитрая функция)</i><br>'
+'});<br>'
+'alert(promise1); <i>//1. [object Promise], 2.mrak (всё верно) и задержка была</i><br>'
+'<li><a>Ещё пример</a><br>'
+'let myProm=new Promise((resolve,reject)=>{<br>'
	+'setTimeout(function(){<br>'
		+'resolve("Atas!"); <i>//smotrim</i><br>'
	+'},1500);<br>'
+'});<br>'
+'myProm.then((fignja)=>{<br>'
	+'alert("Ura! "+fignja); <i>//Ura! Atas! (задержка была</i><br>'
+'});<br></li><li><a>вызов resolve/reject сразу</a><br>'
+'let promise=new Promise(function(resolve,reject){<br>'
	+'resolve(888); <i>//как один из вариантов (для примера)</i><br>'
	+'reject("exit"); <i>//тоже имеет право быть</i><br>'
+'});<br>'
+'<a>Когда код получает один из колбэков, он должен выполнить один из них</a><br>'
+'<i>-resolve(value) - если последовал успех с результатом value</a><br>'
+'<i>-reject(error) - ошибка, error - объект ошибки</i></li><li>'
+'Объект promise есть внутренние свойства:<br>'
+'<ul><li>state("состояние")-вначале "pending"("ожидание"), после '
+'меняется на "fulfielld"("успех") при вызове resolve или на'
+'"rejected"("ошибка") при вызове reject'
+'</li><li>result("результат")-undefined в начале, потом изменяется на value '
+'при вызове resolve(value) или на error при вызове reject(error).<br>'
+'<img src="img/2prom.png">Вот они</img>'
+'<hr><a>Ещё один пример кода</a><br><i>Выполениние второй команды</i><br>'
+'let promise=new Promise(function(resolve,reject){<br>' 
+'setTimeout(()=>reject("done"),10000);<br>'
+'});	<i>//ничего не выводит, но хвалят</i><br>'
+'<i>Первая команда</i><br>'
+'let promise=new Promise(function(resolve,reject){<br>'
	+'setTimeout(()=>resolve("done"),1000);<br>'
+'});<i>//тоже только моргнула</i><br>'
+'<i>Данные функции запускаются сразу же и получают одну из двух'
+' команд на выполнение(я не пробовал, но суть вроде бы понял)</i></li><li>'
+'<i>Поcле просшествия назначенного времени вызывается resolve, '
+'чтобы передать результат</i><br>'
+'<img src="img/resolve.png"><figcaption>resolve</figcaption></li><li>'
+'<i>Теперь пример, где говорится, что случилась ошибка</i><br>'
+'let promise=new Promise(function(resolve,reject){<br>'
	+'setTimeout(()=><br>'
	+'	reject( new Error("Whoops!")<br>'
+' ),1000); <br>'
+'}); <i>//да, ошибка говорит. Ошибка чего, я не знаю</i><br>'
+'<i>//будем разбираться. Но попозже</i><br>'
+'<i>Ща, даже картинку нарисуем</i><br>'
+'<img src="img/error.png"><figcaption>Задача с ошибкой</figcaption></img></li><li>'
+'<a>Может быть что-то одно, или рузультат, или ошибка</a><br>'
+'let promise=new Promise(function(resolve,reject){<br>'
	+'resolve("done");<br>'
	+'reject(new Error("...")); <i>//ignor</i><br>'
	+'setTimeout(()=>resolve("...")); <i>//ignor</i><br>'
+'}); <i>//Полный игнор (но страница загрузилась)</i><br></li><li>'
+'<a>Прикольная штука then</a><br>'
+'promise.then(<br>'
  +' function(result){<i>/*успешное выполнение*/</i>},<br>'
   +'function(error){<i>/*обработает ошибку*/</i>}<br>'
   +'); <i>//выполянется в зависимости от результата</i><br>'
+'<a>Успешное выполнение промиса</a><br>'
+'let promise=new Promise(function(resolve,reject){<br>'
+'	setTimeout(()=>resolve("done!"),1000);<br>'
+'});<br>'
+'<i>//resolve запустит первую функцию</i><br>'
+'promise.then(<br>'
   +'result=>alert(result), <i>//done</i><br>'
  +' error=>alert(error) <i>//ничего</i><br>'
+'   );<br></li>'
+'<li><a>И с ошибкой</a><br>'
+'1et promise=new Promise(function(resole,reject){<br>'
	+'setTimeout(()=>reject(new Error("Whoops")),1000);<br>'
+'});<br>'
+'<i>//reject запустит вторую функцию, переданную в .then</i><br>'
+'promise.then(<br>'
   +'result=>alert(result), <i>//не запустится</i><br>'
  +' error=>alert(error) <i>//Error Whoops через секунду</i><br>'
+'   ); <i>//Error: Whoops(собака)</i><br></li>'
+'<li><a>Для успешного выполнения только</a><br>'
+'let promise=new Promise(resolve=>{<br>'
	+'setTimeout(()=>resolve("done"),1000);<br>'
+'});<br>'
+'promise.then(alert); <i>// 1 сек. и done</i><br></li>'
+'<li><b>catch - </b><a>Для обработки только ошибки</a><br>'
+'let promise=new Promise((resolve,reject)=>{<br>'
	+'setTimeout(()=>reject(new Error("Ошибка!")),1000);<br>'
+'});<br>'
+'promise.catch(alert); <i>//Error: Ошибка! (пойдёт)</i><li><br>'
+'<li><a>Очистка: finnaly</a><i> Не совсем then, но похоже</i><br>'
+'new Promise((resolve,reject)=>{<br>'
	+'setTimeout(()=>resolve("value"),2000);<br>'
+'})<br>'
+'.finally(()=>alert("Promise end")) <i>// сработает первым(да, и задержка была)</i><br>'
+'.then(result=>alert(result)); <i>// <-- .then показывает "value"(сразу же после)</i><br>'
+'<a>Работа функции после finaly продолжается (удобно)</a><i>'
+' где-то такое мы уже видели</i><br>'
+'new Promise((reslve, reject)=>{<br>'
	+'throw new Error("error");<br>'
+'})<br>'
+'.finally(()=>alert("Промис финиш")) <i>// Промис финиш (точки нет)</i><br>'
+'.catch(err=>alert(err)); <i>//Error error (самодеятельность какая-то)</i><br>'
+'finnaly вообще ничгео возвращать не обязан и является просто приблудой разработчиков</li><br><li>'
+'<a>Итог:</a><br>'
+'- Обработчик finally если что-то возвращает, то это игнорируется<br>'
+'- Данный обработчик не получате результата предыдущей обработки.'
+' Результат просто передаётся следующему обработчику(смысл...)<br>'
+'-Если finally выдал ошибку, то она передаётся ближайшему обработчику ошибок.<br></li><li>'
+'<a>loadScript - пример</a><br>'
+'function loadScript(src,callback){<br>'
	+'let script=document.createElement("script");<br>'
	+'script.src=src;<br>'
	+'script.onload=()=>callback(null,script);<br>'
	+'script.onerror=()=>callback(new Error(`Ошибка загрузки скрипта ${src}`));<br>'
	+'document.head.append(script);<br>'
+'} <i>//ничего не вывел. Консоль говорит, что ошибка</i><br>'
+'<a>Перепишем:</a><br>'
+'function loadScript(src){<br>'
	+'return new Promise(function(resolve,reject){<br>'
		+'let script=document.createElement("script");<br>'
		+'script.src=src;<br>'
		+'script.onload=()=>resolve(script);<br>'
		+'script.onerror=()=>reject(new Error(`Ошибка загрузки скрипта ${src}`));<br>'
	+'	document.head.append(script);<br>'
+'});} <i>//смотрим, как использовать далее</i><br>'
+'let promise=loadScript("https://www.google.com");<i>скрипт лень указывать</i><br>'
+'promise.then(<br>'
+'script=>alert(`${script.src} загружен!`), <i>//https://www.google.com/ загружен!</i><br>'
+'error=>alert(`Ошибка: ${error.message}`)<br>'
+');<br>'
+'promise.then(script=>alert("ещё обработчик")); <i>//ещё обработчик</i><br>'
+'</li></ol>'
+'<b>Задачи</b><hr>'
+'<li>new Promise(function(resolve,reject){<br>'
	+'setTimeout(()=>{<br>'
		+'throw new Error("Atas!");<br>'
	+'},1000);<br>'
+'}).catch(alert); <i>//не-а. Просто страницу загрузил</i><br>'
+'</li>'
+'</ol></td><td id="prav">'
+'<ol><h4>Задачи</h4><br>'
+'<li><b>Перевыполним промис(если сможем)</b><br>'
+'let promise=new Promise(function(resolve,reject){<br>'
	+'resolve(1);<br>'
	+'setTimeout(()=>resolve(2),1000);<br>'
+'});<br>'
+'promise.then(alert); <i>//1 (2 не загрузилась)</i></li><br>'
+'<li><a>Задержка на промисах</a><br>'
+'function delay(ms){<br>'
	+'let x;<br>'
	+'x=2+1;<br>'
	+'alert("да, это же "+x); <i>//это вывелось</i><br>'
	+'}<br>'
+'delay(3000).then(()=>alert("прошло три секунды"));<br>'
+'<a>Решение:</a><br>'
+'function delay(ms){<br>'
	+'return new Promise(resolve=>setTimeout(resolve,ms));<br>'
+'}<br>'
+'delay(3000).then(()=>alert("прошло три секунды"));<br>'
+'<i>//загрузилась сначала страница, потом уведомление о 3 сек</i><br>'
+'delay(1000).then(()=>alert("для интереса")); <i>//впереди уведомления</i></li><br>'
+'<li><a>Анимация круга с помощью промиса</a><br>'
+'<button onclick="go()">жми, собака!</button>'
+'function go(){<br>'
+'showCircle(150,150,100).then(div=>{<br>'
	+'div.classList.add("message-ball");<br>'
	+'div.append("Я - красный круг!");<br>'
+'});<br>'
+'}<br>'
+'function showCircle(cx,cy,radius){<br>'
	+'let div=document.createElement("div");<br>'
	+'div.style.width=0;<br>'
	+'div.style.height=0;<br>'
	+'div.style.left=cx+"px";<br>'
	+'div.style.top=cy+"px";<br>'
	+'div.className="circle";<br>'
	+'document.body.append(div);<br>'
	+'return new Promise(resolve=>{<br>'
		+'setTimeout(()=>{<br>'
			+'div.style.width=radius*2+"px";<br>'
			+'div.style.height=radius*2+"px";<br>'
			+'div.addEventListener("transitionend",function handler(){<br>'
				+'div.removeEventListener("transitionend",handler);<br>'
				+'resolve(div);<br>'
			+'});<br>'
		+'},0);<br>'
	+'})<br>'
+'} <i>//Жмёшь на кнопочку и появляется кровавый круг</i><br>'
+'<i>Конечно, код надо перед этим из оболочки достать, но круг появляется</i><br>'
+'</li><li><a>Цепочка промисов</a><br>'
+'<i>Зацени-ка следующий код:</i><br>'
+'new Promise(function(resolve,reject){<br>'
	+'&ensp;setTimeout(()=>resolve(1),1000); <i>//обратим внимание</i><br>'
+'}).then(function(result){ <i>//второй раз заценим</i><br>'
+'alert(result); <i>// 1</i><br>'
+'return result*2;<br>'
+'}).then(function(result){ <i>//третья ходка</i><br>'
   +'&ensp;alert(result); <i>//2</i><br>'
  +' return result*2;<br>'
+'}).then(function(result){<br>'
	+'&ensp;alert(result); <i>//4</i><br>'
	+'return result*2; <i>//ответа нет. Жлобы</i><br>'
+'});<br></li><li><a>нарисуем рисунок(сильно сказал)</a>'
+'<img src="img/then.png"><figcaption>промис и куча обработчиков</figcaption></img><br>'
+'<a>Возвращаем промис</a><i> (Обожаю примеры:)</i><br>'
+'new Promise(function(resolve,reject){<br>'
	+'setTimeout(()=>resolve(1),1000);<br>'
+'}).then(function(result){<br>'
	+'alert(result); <i>//1</i><br>'
	+'return new Promise((resolve,reject)=>{ <i>//(*)</i><br>'
	+'  setTimeout(()=>resolve(result*2),1000);<br>'
+'});<br>'
+'}).then(function(result){ <i>//(**)</i><br>'
  +'alert(result); <i>//2</i><br>'
  +'return new Promise((resolve,reject)=>{<br>'
	+'  setTimeout(()=>resolve(result*2),1000);<br>'
  +'});<br>'
+'}).then(function(result){<br>'
	+'alert(result); <i>//4 (все значения выползли с задержкой в 1с)</i><br>'
+'});<br></li>'
+'<li><a>пример: loadScript</a><br>'
+'<i>//Слудующая приблуда не работает у меня, как использовать, не знаю</i><br>'
+'loadScript("js/sj/one.js")<br>'
   +'.then(function(script){<br>'
	+'   return loadScript("js/sj/two.js");<br>'
   +'})<br>'
   +'.then(function(script){<br>'
	 +'  return loadScript("js/sj/three.js");<br>'
  +'})<br>'
   +'.then(function(script){<br>'
	 +'  <i>//вызываем функции и смотрим...</i><br>'
	   +'one();<br>'
	   +'two();<br>'
	   +'three();<br>'
+'});<i>//даже, что выскочить должно, не в курсе</i><br></li><li>'
+'<a>Обработчик может возвращать не промис, а объект .then</a><br>'
+'class Thenable{<br>'
	+'constructor(num){<br>'
		+'this.num=num;<br>'
	+'}<br>'
	+'then(resolve,reject){<br>'
		+'alert(resolve); <i>// 2 (через две секунды)</i><br>'
      +'   setTimeout(()=>resolve(this.num*2),1000);		 <br>'
	+'}}<br>'
+'new Promise(resolve=>resolve(1))<br>'
   +'.then(result=>{<br>'
    +' return new Thenable(result);<br>'
  +' })<br>'
+'.then(alert); <i>//function () { [native code] }  (через секунду)</i><br>'
+'<a>Объекты добаляются, начхав на промисы</a><hr></li><li>'
+'<a>Подргузка информации с удалённого сервера: fetch</a><br>'
+'<i>Базовый синтаксис:</i><br>'
+'let promise=fetch(url);<br>'
+'"use strict";<br>'
+'fetch("/article/promise-chaining/user.json")<br>'
  +'.then(function(response){<br>'
	+'  return response.text();<br>'
  +'})<br>'
  +'.then(function(text){<br>'
	+'	  alert(text); //<br>'
+'  }); <i>//не работает у меня(ничего не показывает)</i><br>'
+'<i>Стрелочные функции</i><br>'
  +'fetch("/article/promise-chaining/user.json")<br>'
  +'    .then(responce=>response.json())<br>'
+'	  .then(user=>alert(user.name));<br></li>'
+'<li><a>Промисы. Обработка ошибок</a><br>'
+'fetch("/article/promise-chaining/user.json")<br>'
+'.then(response=>response.json())<br>'
+'.then(user=>fetch(`https://api.github.com/users/${user.name}`))<br>'
+'.then(response=>response.json())<br>'
+'.then(githubUser=>new Promise((resolve,reject)=>{<br>'
	+'let img=document.createElement("img");<br>'
	+'img.src=githubUser.avatar_url;<br>'
	+'img.className="promise-avatar-example";<br>'
	+'document.body.append(img);<br>'
	+'setTimeout(()=>{<br>'
		+'img.remove();<br>'
		+'resolve(githubUser);<br>'
	+'},3000);<br>'
+'}))<br>'
+'.catch(error=>alert(error.message)); <i>//Failed to fetch (ну, молодец. И что теперь делать)</i><br></li><li>'
+'<a>Неявный try...catch</a><br>'
+'new Promise((resolve,reject)=>{<br>'
	+'throw new Error("Ошибка!");<br>'
+'}).catch(alert); <i>//Error: Ошибка! (пока всё в порядке)</i><br>'
+'<i>Следующий тоже работает</i><br>'
+'new Promise((resolve,reject)=>{<br>'
	+'reject(new Error("ОшиПка!"));<br>'
+'}).catch(alert); <i>//Error: ОшиПка!</i><br></li><li>'
+'<i>В обработчиках этот метода тоже работает</i><br>'
+'new Promise((resolve,reject)=>{<br>'
	+'resolve("AHA");<br>'
+'}).then((result)=>{<br>'
	+'throw new Error("Ошибка!"); <i>//ляпаем ошибку специально</i><br>'
+'}).catch(alert); <i>//смотрим: ReferenceError: resolve is not defined(что-то ищет ещё)</i><br>'
+'<i>Вот, программная ошибка:</i><br>'
+'new Promise((resolve,reject)=>{<br>'
	+'resolve("AHA");<br>'
+'}).then((result)=>{<br>'
	+'beliberda(); <i>//нет такого</i><br>'
+'}).catch(alert); <i>//ReferenceError: beliberda is not defined (то-же самое)</i><br>'
+'<i>В данном случае .catch последний перехватывает все ошибки</i></li><li>'
+'<a>Пробрасывание ошибок</a><br>'
+'.catch успешно пробрасывает ошибку. Пишем ниже<br>'
+'new Promise((resolve,reject)=>{<br>'
	+'throw new Error("Ошибка");<br>'
+'}).catch(function(error){<br>'
	+'alert("Ошибка обработана, работаем дальше"); <i>//(1)Ошибка обработана, работаем дальше</i><br>'
+'}).then(()=>alert("управление переходит в слудующий .then")); <i>//(2)управление переходит в слудующий .then</i><br></li><li>'
+'<a>Ещё одна приблуда, когда перехвачена ошибка, но не обработана</a><br>'
+'new Promise((resolve,reject)=>{<br>'
	+'throw new Error("Ошибка");<br>'
+'}).catch(function(error){ <i>//(*)</i><br>'
  +'if(error instanceof URLError){<br>'
  +'<i>//обрабатываем ошибку</i><br>'
  +'}else{<br>'
	  +'alert("Сейчас нет возможности");<br>'
	+'  throw error; <i>//пробрасывает ошибки в слудующий catch</i><br>'
  +'}<br>'
+'}).then(function(){<br>'
	+'<i>/*NO*/</i><br>'
+'}).catch(error=>{ <i>//(**)</i><br>'
  +'alert(`неизветсная ошибка: ${error}`); <i>//неизветсная ошибка: ReferenceError: URLError is not defined</i><br>'
  +'<i>1//нет возаращения =>вполняется дальше</i><br>'
+'});<br></li><li><a>Необработанные ошибки</a><br>'
+'new Promise(function(){<br>'
	+'noSuchFunction(); <i>//ошибка (функций нет)<i><br>'
+'}).then(()=>{ <i>//далее идут обработчики</i><br>'
+'}); <i>//а .catch нет. поэтому моргунул и загрузил код</i><br>'
+'<i>Гворят в консоли можно увидеть. Но не смотрел. Лень. Да, там, как всегда ошибок полно</i></li><br>'
+'<li><a>Вот пример чисто для страницы браузера</a><br>'
+'window.addEventListener("unhandledrejection",function(event){<br>'
	+'<i>//объект имеет два спецсвойства</i><br>'
	+'alert(event.promise); <i>//Error: Ошибка</i><br>'
	+'alert(event.reason); <br>'
+'});<br>'
+'new Promise(function(){<br>'
	+'throw new Error("Ошибка"); <i>//(<anonymous>)</i><br>'
+'}); <i>//нет обработчика ошибок </i><br>'
+'<i>//(Системная ошибка: net::ERR_FILE_NOT_FOUND..)</i><br>'
+'<i>//одно слово жуть</i><br>'
+'</li></ol>'
+'<ul><a>А, итог...</a><br>'
+'<li>.catch перехватывает все виды ошибок в промисах: будь то reject или throw</li>'
+'<li>.then также перехватывает ошибки, если задан второй аргумент</li>'
+'<li>Наобходимо размещать там .catch, где есть ошибка. Если не указать её, '
+'то обработчик может её принять за программную</li>'
+'<li>.catch можно совсем не использовать, если не уверены в способе вогсстановления</li>'
+'<li>обработчик unhandledrejection используйте в любом случае, чтобы приложение '
+'не умирало просто так</li></ul>'
+'</td></table>'

let papi;
papi='<table><td id="levcool">'
+'<ul><i><h3>Promise API</h3/i><li>'
+'<i>Запуск нескольких промисов параллельно</i><br>'
+'let promise=Promise.all(iterable);'
+'<iТут Promise.all выполнится спястя три секунды></i><br>'
+'Promise.all([<br>'
   +'new Promise(resolve=>setTimeout(()=>resolve(1),3000)), <i>// 1</i><br>'
   +'new Promise(resolve=>setTimeout(()=>resolve(2),2000)), <i>// 2</i><br>'
   +'new Promise(resolve=>setTimeout(()=>resolve(3),1000)) <i>// 3</i><br>'
  +' ]).then(alert); <i>//1,2,3 (с задержкой конечно. И мы - рады)</i><br>'
+'   <i>//каждый промис вставил свою лепту</i><br></li><li>'
+'<a>Промисы: обработка ошибок</a><br>'
+'<i>Зацените:</i><br>'
+'fetch(`https://no-such-server.blabla`) <i>//Белиберда</i><br>'
+'.then(rexponse=>responce.json())<br>'
+'.catch(err=>alert(err)) <i>// TypeError: Failed to fetch</i><br>'
+'fetch(`https://www.google.com`) <i>//серьёзный сайт</i><br>'
+'.then(rexponse=>responce.json())<br>'
+'.catch(err=>alert(err)) <i>//та же история</i><br></li><li>'
+'<i>Перехват ошибок, используя catch в самом конце</i><br>'
+'fetch("/article/promise-chaining/user.json")<br>'
  +'.then(response=>response.json())<br>'
  +'.then(user=>fetch(`https://a[i.github.com/users/${user.name}`))<br>'
  +'.then(response=>response.json())<br>'
  +'.then(githubUser=>new Promise((resolve,reject)=>{<br>'
	+'  let img=document.createElement("img");<br>'
	  +'img.src=githubUser.avatar_url;<br>'
	  +'img.className="promise-avatar-example";<br>'
	  +'document.body.append(img);<br>'
	+'setTimeout(()=>{<br>'
      +'img.remove();<br>'
	  +'resolve(githubUser);<br>'
	+'},3000);<br>'
  +'}))<br>'
  +'.catch(error=>alert(error.message)); <i>//Failed to fetch (проблема с сетью'
  +', а должно быть фото )Так, немного повторили, тоже неплохо</i><br></li><li>'
  +'<br><a>Имеем массив ссылок</a><br>'
  +'let urls=[<br>'
  +'`https://api.github.com/users/iliakan`,<br>'
  +'`https://api.github.com/users/remy`,<br>'
  +'`https://api.github.com/users/jeresig`<br>'
  +'];<br>'
  +'<i>//Преобразуем каждый url в промис, возаращённый fetch</i><br>'
  +'let requests=urls.map(url=>fetch(url));<br>'
  +'<i>//promise.all будет ожидать выполнения всех промисов</i><br>'
  +'Promise.all(requests)<br>'
  +'.then(responses=>responses.forEach(<br>'
    +'response=>alert(`${response.url}:${response.status}`)<br>'
	+')); <i>//https://api.github.com/users/iliakan:200</i><br>'
	  +'  <i>//https://api.github.com/users/remy:200</i><br>'
		+'<i>//https://api.github.com/users/jeresig:200</i><br></li><li>'
+'<i>Исследуем пример с получением информации о пользователе</i><br>'
+'let names=["iliakan","remy","jeresig"];<br>'
+'let requests=names.map(name=>fetch(`https://api.github.com/users/$[name]`));<br>'
+'Promise.all(requests)<br>'
+'.then(responses=>{ <i>//промисы успешно заверешены</i><br>'
+'for(let response of responses){<br>'
  +'alert(`${response.url}: ${response.status}`); <i>//должен показать везде 200</i><br>'
+'}	<br>'
+'return responses;<br>'
+'})<br>'
+'<i>//надо преобразовать массив ответов в response.json()<br>'
+'<i>//прочитать, что внутри</i><br>'
+'.then(responses=>Promise.all(responses.map(r=>r.json())))<br>'
+'<i>//всё обработано, users - массив с результатами</i><br>'
+'.then(users=>users.forEach(user=>alert(user.name)));<br>'
+'<i> результат:</i> <br><a>'
             +'https://api.github.com/users/$[name]: 404<br>'
			 +'https://api.github.com/users/$[name]: 404<br>'
			+' https://api.github.com/users/$[name]: 404<br>'
			+' https://api.github.com/users/$[name]: 404<br>'
          +'           undefined<br>'
        +'             undefined<br>'
      +'                undefined<br>'
    +'                  undefined<br>'
  +'           exit;					<br>'  
+'             </a>( Не поленился же)<hr></li>'
+'<a>Ещё раз catch</a><br>'
+'<li>const myPromise=new Promise(function(resolve,reject){<br>'
    +'alert("Выполнение асинхронной операции"); <i>//Выполнение асинхронной операции Prom 488</i><br>'
	+'reject("Переданы некорректные данные"); <i>//Переданы некорректные данные</i><br>'
+'});<br>'
+'myPromise.catch(function(error){<br>'
	+'(error); <i>//а тут ничгео не вывела</i><br>'
+'});<br>'
+'<a>При вызове несуществующей функции, всё равно генерируется ошибка(вот, зараза)</a><li><br>'
+'const myPromise=new Promise(function(resolve){<br>'
	+'alert("Выполнятеся ассинхронная операция"); <i>//Выполнятеся ассинхронная операция</i><br>'
	+'gSW(); <i>//нет такой. ReferenceError: gSW is not defined</i><br>'
	+'resolve("Hello world!");<br>'
+'});<br>'
+'myPromise.catch(function(laga){<br>'
	+'console.log(laga); <i>//ReferenceError: gSW is not defined</i><br>'
+'}); <i>//при нажатии на ошибку показывает мой код(и всё...)</i></li><br>'
+'<a>Ошибка как результат вызова throw</a><br>'
+'<li>const myPromise=new Promise(function(resolve,reject){<br>'
	+'console.log("Асинхронная операция однако");<br>'
	+'const parsed=parseInt("Atas");<br>'
	+'if(isNaN(parsed)){<br>'
	+'throw "Not a number"; <i>//генерация ошибки</i><br>'
	+'}<br>'
	+'resolve(parsed); <i>//Not a number</i><br>'
+'});<br>'
+'myPromise.catch(function(error){<br>'
	+'console.log(error); <i>//тут код ошибки(не разбирался в нём)</i><br>'
+'});  <i>//генерация сообщения об ошибке, даже если её нет</i> <br></li>'
+'<li><a>Рассмотрим необработанные ошибки</a><br>'
+'<i>Забыли добавить .catch в конец цепочки:</i><br>'
+'new Promise(function(){<br>'
	+'noSuchFunction(); <i>//нет такой функции(ошибка)</i><br>'
+'})<br>'
+'.then(()=>{<br>'
	+'<i>//обработчики ,then</i><br>'
+'});<i> //.catch нет на конце</i><br>'
+'<i>//полностью страницу не загрузил, потому что нет обработчика(ждёт) </i><br>'
+'<i>Но в браузере можно поймать такие ошибки</i><br>'
+'window.addEventListener("unhandledrejection",function(event){<br>'
	+'<i>//объект обладает двумя особыми свойствами:</i><br>'
	+'alert(event.promise); <i>//[object Promise]</i><br>'
	+'alert(event.reason); <i>//Error: Ошибка (оба сообщения два раза)</i><br>'
+'});<br>'
+'new Promise(function(event){<br>'
	+'throw new Error("Ошибка");<br>'
+'}); // ну, страница загрузилсь<br>'
+'</li></ul>'
+'<ol><b>Итог забацаем:</b>'
+'<li>.catch перехватывает все виды ошибок в промисах: будь то вызов reject() '
+'или ошибка, брошенная в обработчике при помощи throw</li>'
+'<li>.then также перехватывает ошибки таким же образом, если задан второй '
+'аргумент, который является обработчиком ошибок</li>'
+'<li>Необходимо размещать ,catch там, где мы хотим обработать ошибки и знаем, '
+'как это сделать. Умный обрабтчик может пробросить ошибку, если ничего о ней не '
+' знает или проанализировать её, используя полезные пользовательские классы</li>'
+'<li>.catch можно и совсем не использовать, если восстановиться после ошибки '
+'нормально не предоставляется</li>'
+'<li>При любом раскладе надо использовать обработчик unhandlerrejection, '
+'которые отслуживает все ошибки и информирует о них текущего пользователя и сервер, '
+'которому интересно запихать свой нос, куда не надо</li>'
+'</ol>'
+'<b>И, задачи коненчо:</b><br>'

+'</td><td id="pravcool">'
+'<ul><h4>Промисификация</h4><li>'
+'<i>Делаем из колбэков промисы</i><br>'
+'function loadScript(src,callback){<br>'
	+'let script=document.createElement("script");<br>'
	+'script.src=src;<br>'
	+'script.onload=()=>callback(null,script);<br>'
	+'script.onerror=()=>callback(new Error(`Ошибка скрипта ${src}`));<br>'
	+'document.head.append(script);<br>'
+'} <i>//будем мумифицировать её</i><br>'
+'let loadScriptPromise=function(src){<br>'
	+'return new Promise((resolve,reject)=>{<br>'
		+'loadScript(src,(err,script)=>{<br>'
		+'	if(err)reject(err)<br>'
	+'			else resolve(script);<br>'
+'});})}<br>'
+'<i>//далее следует функция -помошник для мумификации более одной функции</i><br>'
+'<i>//после кода которой у меня деже страница не загрузилась(для меня бесполезная)</i><br>'
+'function promisify(f){<br>'
	+'return function(...args){ <i>//возвращение функции-обёртки</i><br>'
	   +'return new Promise((resolve,reject)=>{<br>'
		   +'function callback(err,result){ <i>//спец колбэк</i><br>'
			   +'if(err){<br>'
				+'   reject(err);<br>'
			  +' }else{<br>'
			+'	   resolve(result);<br>'
		  +' }}<br>'
		+'   args.push(callback); <i>//колбэк в конец аргументов</i><br>'
	+'   f.call(this, ...args); <i>//вызов оригинальной функции</i><br>'
+'});};};<br>'
+'<i>//используем</i><br>'
+'let loadScriptPromise=promisify(loadScript);<br>'
+'loadScriptPromise(...).then(...);<br></li><li>'
+'<i>Напишем улучшенную функцию и напихаем в неё кучу аргументов (promisify '
+'(f, true) и получаем массив результатов)</i><br>'
+'function loadScript(src,callback){<br>'
	+'let script=document.createElement("script");<br>'
	+'script.src=src;<br>'
	+'script.onload=()=>callback(null,script);<br>'
	+'script.onerroe=()=>callback(new Error(`Ошибка загрузки ${src}`));<br>'
	+'document.head.append(script);<br>'
+'}<br>'
+'let loadScriptPromise=function(src){<br>'
	+'return new Promise((resolve,reject)=>{<br>'
		+'loadScript(src,(err,script)=>{<br>'
		+'	if(err)reject(err)<br>'
	+'			else resolve(script);<br>'
+'});})}<br>'
+'function promisify(f){<br>'
	+'return function(...args){ <i>//возврат функции обёртки</i><br>'
	+'return new Promise((resolve,reject)=>{<br>'
		+'function callback(err,result){ <i>//спец колбэк</i><br>'
		  +'if(err){<br>'
			+'  reject(err);<br>'
		 +' }else{<br>'
			+'  resolve(result);<br>'
		+'}}<br>'
		+'args.push(callback); <i>//колбэк в конец</i><br>'
	+'	f.call(this,...args); <i>//оргинальная функция</i><br>'
+'});};};<br>'
+'<i>//страница загрузилась. Что выполнилось - непонятно. Консоль в хламе</i><br>'
+'</li></ul>'
+'<ol><b>Микрозадачи</b><br>'
+'<span style="padding-left:10px">Демо:</span><br>'
+'<li>let promise=Promise.resolve();<br>'
+'promise.then(()=>alert("promis end")); <i>//promis end второе сообщение</i><br>'
+'alert("код выполнен"); <i>//код выполнен первое сообщение</i><br>'
+'<img src="img/кодV.png" alt="end">'
+'<i>Можно также вывети сначала сообщение "код выполнен" после "промис выполнен"</i><br>'
+'Promise.resolve()<br>'
+'.then(()=>alert("промис выполнен")) <i>//1</i><br>'
+'.then(()=>alert("код выполнен")); <i>//2, что реально грамотней</i><br></li><li>'
+'<i>При ожидании ошибки:</i><br>'
+'let promise=Promise.reject(new Error("В промисе ошибка"));<br>'
+'promise.catch(err=>alert("поймали")); <i>//поймали</i><br>'
+'window.addEventListener("unhandledrejection",event=>{<br>'
	+'alert(event.reason);<br>'
+'}); <i>//пусто, но заргурзка есть</i><br>'
+'<i>//забываем добавить catch:</i><br>'
+'let promise=Promise.reject(new Error("В промисе ошибка"));<br>'
+'window.addEventListener("unhandrejection",event=>alert(event.reason));<br>'
+'<i>Тоже только загрузка страницы</i><br>'
+'<i>А теперь перед ошибкой, мы долго ждём этого осбытия:</i><br>'
+'let promise=Promise.reject(new Error("Ошибка однако"));<br>'
+'setTimeout(()=>promise.catch(err=>alert("вот она")),1000); <i>//вот она, с задержкой естественно</i><br>'
+'window,addEventListener("unhandledrejection",event=>alert(event.reason));<br>'
+'</li></ol></td></table>'

let nach;
nach='<table><td id="levcool">'
+'<li><b>Что такое set</b><br>'
+'<i>объясняем на пальцах</i><br>'
+'"use strict";<br>'
+'let set=new Set();<br>'
+'let vasya={name: "Вася"};<br>'
+'let petya={name: "Петя"};<br>'
+'let dasha={name: "Даша"};<br>'
+'<i>//некоторых пользователей не выгонишь</i><br>'
+'set.add(vasya);<br>'
+'set.add(petya);<br>'
+'set.add(dasha);<br>'
+'set.add(vasya);<br>'
+'set.add(petya);<br>'
+'<i>//сохраняются только уникальные значения</i><br>'
+'alert(set.size);<i> //3</i><br>'
+'set.forEach(user=>alert(user.name)); <i>//Вася, Петя,Даша<i><br>'
+'</li>'
+'<ol><b>Async/await</b><br>'
+'<li><i>Асинхронные функции</i><br>'
+'async function f(){ <i>//async -ключевое слово для работы с промисами</i><br>'
	+'return 1;<br>'
+'} alert(f()); <i>//объект Promise! (а ты думал)</i><br>'
+'<i>Cледующая функция возвращает выполненный промис:</i><br>'
+'async function f(){<br>'
	+'return 1;<br>'
+'}<br>'
+'f().then(alert); <i>//1 а вот тута единицу возвратила</i><br>'
+'<i>Можно вернуть сразу промис напрямую(больше писать)</i><br>'
+'async function f(){<br>'
	+'return Promise.resolve(1);<br>'
+'} f().then(alert); <i>//1 результат тот-же</i><br></li><li>'
+'<i>Await - используется внутри async</i><br>'
+'let value=await promise;<br>'
+'async function f(){<br>'
	+'let promise=new Promise((resolve,reject)=>{<br>'
		+'setTimeout(()=>resolve("Готово!"),1000)<br>'
	+'});<br>'
	+'let result=await promise; <i>//будет задержка</i><br>'
	+'alert("готово"); <i>//отобразится она</i><br>'
+'}<br>'
+'f(); <i>//готово</i><br>'
+'<a>! await нельзя использовать внутри функции без async</a><br>'
+'</li><li>'
+'<a>Давайте перепешем ранее рассмотренный пример:</a><br>'
+'<i>1. заменим .then на await<br>2. добавим ключевое слово async перед функцией</i><br>'
+'<i>Сначала асинхронную операцию, используя FetchAPI</i><br>'
+'function fDFA(){<br>'
  +' fetch("https://v2.jokeapi.dev/joke/Programming?type=single")<br>'
+'.then(res=>res.json())<br>'
+'.then(json=>alert(json.joke));<br>'
+'}<br>'
+'fDFA();<br>'
+'alert("Finish data"); <i>//Finish data<br>'
  +'      //If Bill Gates had a dime for every time Windows crashed ...<br>' 
+'		//Oh wait, he does. (шутка про Билла Гейтса)</i>- Неправильный порядок  <br>'
+'<i>А теперь пометим функцию, как асинхронную и применим async</i><br>'
+'async function fDFA(){<br>'
	+'fetch("https://v2.jokeapi.dev/joke/Programming?type=single")<br>'
	+'.then(res=>res.json())<br>'
	+'.then(json=>alert(json.joke));<br>'
+'} <i>//функцию не закрываем. Идём дальше:</i><br>'
+'fDFA()<br>'
+'.then(()=>{<br>'
	+'alert("Finich data"); <i>//вывела такое(и копировать не даёт)</i><br>'
+'}); <i>//потом вывела это: The glass is neither half-full nor<br>'
  +' // half-empty, the glass is twice as big as it needs to be.<br>'
+'   //как всё понимать, я не разбирался</i><br></li><li>'
+'<i>Теперь await</i><br>'
+'async function fDFA(){<br>'
	+'const res=await fetch("https://v2.jokeapi.dev/joke/Programming?type=single");<br>'
	+'const json=await res.json();<br>'
	+'alert(json.joke);<br>'
+'} <i>//дожидаемся результата вызова<br>'
+'"await fDFA();<br>'
+'alert("Finish data");" //ничего на загружается, поэтому пока обёртываем код в<br>' 
+'// собственную функцию</i><br>'
+'async function init(){<br>'
	+'await fDFA();<br>'
	+'alert("priplyli");<br>'
+'} init(); <i>//целый диалог, потом - I`d tell you a joke about NAT but<br>'
+'// I would have to translate. И "приплыли"</i><br>'
+'<i>Ещё один прымер</i><br>'
+'function resolveAfter25Seconds(x){<br>'
	+'return new Promise((resolve)=>{<br>'
		+'setTimeout(()=>{<br>'
			+'resolve(x);<br>'
		+'},2000);<br>'
	+'});<br>'
+'} async function f1(){<br>'
  +'let x=await resolveAfter25Seconds(10); <i>//!-await</i><br>'
  +'alert(x); <i>// да, 10 через три секундыБ</i><br>'
+'}f1();  //тут значение преобразуется к успешному промису<br>'
+'<a>Если промис отклонён, то:</a><i>пишем отдельно...</i><br>'
+'async function f2(){<br>'
	+'let y=await 20; <i>//async не нужен</i><br>'
	+'alert(y); <i>// должно двадцаточку выдать</i><br>'
+'}f2(); <i>//20, как с куста (исключение проморгали)</i><br>'
+'<i>Отклоняем промис (зачем-то)(</i><br>'
+'async function f3(){<br>'
	+'try{<br>'
		+'var z=await Promice.reject(30);<br>'
	+'}catch(e){<br>'
		+'alert(e); //<br>'
+'}}f(3); <i>//вааще ничего не загружается</i><br>'
+'<i>Обрабатываем отклонённый промис</i><br>'
+'let response=await promisedFunction().catch((err)=>{<br>'
	+'alert(err);<br>'
+'}); <i>//аналогично предыдущему варианту</i><br>'
+'<a>рабочий вариант</a><br>'
+'async function f(){<br>'
	+'let promise=new Promise((resolve,reject)=>{<br>'
		+'setTimeout(()=>resolve("Готово"),1000)<br>'
	+'});<br>'
	+'f(); <i>//ничего не загружает</i><br>'
	+'let result=await promise;<br>'
	+'alert(result);<br>'
+'}<br>'
+'f(); <i>//Готово(пойдёт)</i><br></li><li>'
+'<a>Перепесиваем промис с использованием async/await</a><br>'
+'fetch("coffeee.jpg") <i>//метод позволяет получать данные из сети</i><br>'
  +'.then((response)=>{<br>'
	  +'if(!response.ok){<br>'
		+'  throw new Error(`HTTP error! status:${respose.status}`);<br>'
	  +'}else{<br>'
	+'	  return response.blob();<br>'
  +'}})<br>'
  +'.then((myBlob)=>{<br>'
	  +'const objectURL=URL.createObjectURL(myBlob);<br>'
	  +'const image=document.createElement("img");<br>'
	  +'image.src=objectURL;<br>'
	+'  document.body.appendChild(image);<br>'
  +'})<br>'
  +'.catch((e)=>{<br>'
	  +'alert(<br>'
	+'  "Здесь проблема с вашей операцией fetch: "+e.message,<br>'
+'  );}); <i>//Здесь проблема с вашей операцией fetch: Failed to fetch</i><br></li><li>'
+'<a>Переписываем код, используя async/await и заценим разницу</a><br>'
+'async function myFetch(){<br>'
	+'const response=await fetch("tea.jpg");<br>'
	+'if(!response.ok){<br>'
		+'throw new Error(`HTTP error! status:${response.status}`);<br>'
	+'}else{<br>'
		+'const myBlob=await response.blob();<br>'
		+'const objectURL=URL.createObjectURL(myBlob);<br>'
		+'const image=document.createElement("img");<br>'
		+'image.src=objectURL; <i>//адреса нет, места тоже</i><br>'
	+'	document.body.appendChild(image); <i>//ничего не знаю, открывай</i><br>'
+'}}<br>'
+'myFetch().catch((e)=>{<br>'
	+'alert(<br>'
	+'"Это проблема с вашим сетевым оператором: "+e.message,);<br>'
+'}); <i>//Это проблема с вашим сетевым оператором: Failed to fetch'
+'      <br>В общем, проблем у тебя - куча</i><br>'
+'<a>А ещё есть гибридный подход:</a><br>'
+'async function myFetch(){<br>'
	+'const response=await fetch("tea.jpg");<br>'
	+'if(!response.ok){<br>'
		+'throw new Error(`HTTP error! status: ${response.status}`);<br>'
	+'}else{<br>'
		+'return await response.blob();<br>'
+'}}<br>'
+'myFetch()<br>'
  +'.then((blob)=>{<br>'
	+'  const objectURL=URL.createObjectURL(blob);<br>'
	  +'const image=document.createElement("img");<br>'
	  +'image.src="img/nasl.png";<br>'
	  +'document.body.appendChild(image);<br>'
  +'})<br>'
  +'.catch((e)=>alert(e)); <i>//type error. File to fetch</i><br>'
+'<i>работает хорошо, но пистаь всё равно много</i><br>'
+'<a>Объясним, зачем это надо</a><i>(а потом вместе посмеёмся)</i><br>'
+'<a>Увидев следующую строку, программа испугается, но будет работать дальше</a><br>'
+'</li><li><a>Await и Promise.all()</a><br>'
	+'async function fetchAndDecode(url,type){<br>'
		+'const response=await fetch(url);<br>'
		+'let content;<br>'
		+'if(!response.ok){<br>'
			+'throw new Error(`HTTP error! status: ${response.status}`);<br>'
		+'}else{<br>'
			+'if(type==="blob"){<br>'
				+'content=await response.blob();<br>'
			+'}else if(type==="text"){<br>'
				+'content=await response.text();<br>'
			+'}<br>'
		+'	return content;<br>'
	+'}} <br>'
	+'async function displayContent(){<br>'
		+'const coffee=fetchAndDecode("coffee.jpg","blob");<br>'
		+'const tea=fetchAndDecode("Tea.jpg","blob");<br>'
		+'const description=fetcnAndDecode("description.txt","text");<br>'
	+'const values=await Promise.all([coffee,tea,description]);<br>'
    +'    const objectURL1=URL.createObjectURL(values[0]);<br>'
  +'      const objectURL2=URL.createObjectURL(values[1]);		<br>'
+'		const descText=value[2];<br>'
		+'const image1=document.createElement("img");<br>'
	+'	const image2=document.createElement("img");<br>'
+'		image1.src=objectURL1;<br>'
		+'image2.src=objectURL2;<br>'
	+'	document.body.appendChild(image1);<br>'
+'		document.body.appendChild(image2);<br>'
		+'const para=document.createElement("p");<br>'
		+'para.taxtContent=descText;<br>'
		+'document.body.appendChild(para);<br>'
	+'}<br>'
	+' displayContent().catch((e)=>alert(e));<br>'
+'		<i>//ReferenceError: fetcnAndDecode is not defined</i><br>'
+'</li>'
+'<li><a>раздельное выполнение async/await</a><br>'
+'function timeoutPromise(interval){<br>'
	+'return new Promise((resolve,reject)=>{<br>'
		+'setTimeout(function(){<br>'
			+'resolve("done");<br>'
		+'}, interval);<br>'
	+'});} <i>//начало есть</i><br>'
	+'<i>//Далее асинхранная функция ожидающая три вызова</i><br>'
	+'<i>//первый пример</i> <br>'
	+'vasync function timeTest(){<br>'
		+'await timeoutPromise(3000);<br>'
		+'await timeoutPromise(3000);<br>'
		+'await timeoutPromise(3000);<br>'
	+'} <br>'
	+'<i>//второй пример</i><br>'
	+'async function timeTest(){<br>'
		+'const timeoutPromise1=timeoutPromise(3000);<br>'
		+'const timeoutPromise2=timeoutPromise(3000);<br>'
	+'	const timeoutPromise3=timeoutPromise(3000);<br>'
		    +'await timeoutPromise1;<br>'
			+'await timeoutPromise2;<br>'
		+'	await timeoutPromise3;<br>'
	+'}<br>'
	+'const startTime=Date.now();<br>'
	+'timeTest().then(()=>{<br>'
		+'const finishTime=Date.now();<br>'
		+'const timeTaken=finishTime-startTime;<br>'
		+'alert("Конечное время в миллисекундах: "+timeTaken);<br>'
	+'}); <i>//1. Конечное время в миллисекундах: 9021</i><br>'
+'	<i>//2. Конечное время в миллисекундах: 3014 (причём один раз)</i><br></li><li>'
+'<a>Async/await class methods (возврашение в итоге промисов)</a><br>'
+'class Person{<br>'
	+'constructor(first,last,age,gender,interests){<br>'
		+'this.name={<br>'
			+'first,<br>'
			+'last,<br>'
		+'};<br>'
		+'this.age=age;<br>'
		+'this.gender=gender;<br>'
		+'this.interests=interests;<br>'
	+'}<br>'
	+'async greeting(){<br>'
		+'return await Promise.resolve(`Hi! im ${this.name.first}`);<br>'
	+'}<br>'
	+'farewell(){<br>'
	+'alert(`${this.name.first}has left the building.Bye for now!`);<br>'
+'}}<br>'
+'const han=new Person("Han","Solo",25,"male",["Smuggling"]);<br>'
+'<i>//используем:</i><br>'
+'han.greeting().then(alert); <i>//Hi! im Han (логика. Где остальное...)'
+'Читай объявленный промис</i><br></li><li>'
+'<a>Итог:</a><br>'
+'<table border="1"><i>асинхронный и обычный итераторы</i>'
+'<tr><td>|||</td><td><b>Перебираемый объект</b></td><td><b>Асинхронно перебираемый</b></td></tr>'
+'<tr><td>Метод для получения итератора</td><td>Symbol.iterator</td>'
+'<td>Symbol.asyncIterator</td></tr>'
+'<tr><td>next() возвращает</td><td>{value:..., done: true/false}</td>'
+'<td>промис, который завершается{value:..., done:true/false}</td></tr>'
+'<tr><i>Различия между асинхронным и обычным генераторами</i></tr>'
+'<tr><td>|||</td><td>Генараторы</td><td>Фсинхронные генераторы</td></tr>'
+'<tr><td>Объявление</td><td>Function*</td><td>async function*</td></tr>'
+'<tr><td>generator.next() возвращает</td><td>{value:..., done: true/false}</td>'
+'<td>промис, который завершается с {value:..., done: true/false}</td></tr>'
+'</table>'
+'</li>'
+'</ol></td><td id="pravcool"><ul>'
+'<b>Генараторы, продвинутая итерация</b><br>'
+'<li><a>Генераторы</a><br>'
+'<i>Функция-генератор</i> function*<br>'
+'function* generateSequence(){<br>'
	+'yield 1;<br>'
	+'yield 2;<br>'
	+'return 3;<br>'
+'}<br>'
+'<i>Сначал создаётся генератор для урпавления функцией:</i><br>'
+'function* generateSequence(){<br>'
	+'yield 1;<br>'
	+'yield 2;<br>'
	+'return 3;<br>'
+'} <i>//функция создаёт объект "генератор"</i><br>'
+'let generator=generateSequence();<br>'
+'let one=generator.next();<br>'
+'alert(JSON.stringify(one)); <i>// {"value":1,"done":false}</i> Что бы это ни значило<br>'
+'<i>Ещё раз вызовем эту функцию</i><br>'
+'let two=generator.next();<br>'
+'alert(JSON.stringify(two)); <i>//{value: 2,done: false} - должно быть(не проверял)</i><br>'
+'<i>И последнее (теперь полностью пропишем)</i><br>'
+'function* generateSequence(){<br>'
	+'yield 1;<br>'
	+'yield 2;<br>'
	+'return 3;<br>'
+'} let generator=generateSequence();<br>'
+'let three=generator.next();<br>'
+'alert(JSON.stringify(three)); {"value":1,"done":false} <i>//должно быть 3. Запускал только конец кода</i><br></li><li>'
+'<a>Перебор генераторов через for...of</a><br>'
+'function* generateSequence(){<br>'
	+'yield 11;<br>'
	+'yield 22;<br>'
	+'yield "mrak";<br>'
	+'return 33;<br>'
+'}<br>'
+'let generator=generateSequence();<br>'
+'for(let value of generator){<br>'
	+'alert(value); <i>//11,22,mrak</i><br>'
+'} <i>//чтобы отобразились все значнеия, нодо возращать все через yield</i><br>'
+'<i>генаратор расширения также пойдёт:</i><br>'
+'function* generateSequence(){<br>'
	+'yield 1;<br>'
	+'yield 2;<br>'
	+'yield 3;<br>'
+'}<br>'
+'let sequence=[0,"myaso", ...generateSequence()]; <i>//небольшая хитрость</i><br>'
+'alert(sequence); <i>//0,myaso,1,2,3</i><br></li><li>'
+'<i>Давайте вспомним созданный нами объект range</i><br>'
+'let range={<br>'
	+'from: 1,<br>'
	+'to: 5,<br>'
	+'[Symbol.iterator](){ <i>//возврат перебираемого объекта и работа только с ним</i><br>'
	  +'return{<br>'
		  +'current: this.from,<br>'
		  +'last: this.to,<br>'
		  +'next(){ <i>//вызывается при каждой итерации</i><br>'
		 +'   if(this.current<=this.last){<br>'
				+'return{done: false, value: this.current++};<br>'
			+'}else{<br>'
		+'		return{done:true};<br>'
	+'	  }}<br>'
+'};}};<br>'
+'<i>//будут выведены числа от одного до пяти</i><br>'
+'alert([...range]); <i>//1,2,3,4,5 (ну, надо-же)</i><br>'
+'<i>Ещё один range с более компактным итератором:</i><br>'
+'let range={<br>'
	+'from: 3,<br>'
	+'to: 8,<br>'
	+'*[Symbol.iterator](){ <i>//[Symbol.iterator]: function*() - краткая запись</i><br>'
	  +'for(let value=this.from; value<=this.to;value++){<br>'
	+'	  yield value;<br>'
+'}}};<br>'
+'alert([...range]); <i>//3,4,5,6,7,8</i><br></li><li>'
+'<a>Встраивание генераторов один в другой</a><br>'
+'function* generateSequence(start,end){<br>'
  +' for(let i=start;i<=end;i++)yield i;<br>'
+'} <i>// основная функция цикла</i><br>'
+'<i>//поехали</i><br>'
+'function* generatePasswordCodes(){<br>'
+'<i>//0...9</i><br>'
+'yield* generateSequence(48,57);<br>'
+'<i>//A...Z </i><br>'
+'yield* generateSequence(65,90);<br>'
+'<i>//a...z </i><br>'
+'yield* generateSequence(97,122);<br>'
+'}<br>'
+'let str="";<br>'
+'for(let code of generatePasswordCodes()){<br>'
  +' str +=String.fromCharCode(code);<br>'
+'}<br>'
+'alert(str); <i>//0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
+' - три куска всё равно в один соединились</i><br></li><li>'
+'<i>yield не тольбко возращает значение, но и  может передавать значнеие извне</i><br>'
+'function* gen(){<br>'
	+'<i>//вопрос-ответ</i><br>'
	+'let result=yield"2+2=?"; <i>//для примера</i><br>'
	+'alert(result); <i>//пока ничего </i><br>'
+'}<br>'
+'let generator=gen();<br>'
+'let question=generator.next().value; <i>//возращает значение</i><br>'
+'generator.next(8+2); <i>//10 (тоже для примера)</i><br>'
+'<i>Специально мозги пудрят. Весело</i><br></li><li>'
+'<a>generator next</a><br>'
+'function* gen(){<br>'
   +'<i>//передача во внешний код</i><br>'
   +'let result=yield "2+2=?";<br>'
  +' alert(result);<br>'
+'}<br>'
+'let generator=gen();<br>'
+'let question=generator.next().value;<br>'
+'generator.next(4+4);<i> //8</i>   <br>'
+'<ol>'
+'<li>Первый вызов generator.next() - всегда без аргумента, он начинает '
+'выполнение и возвращает результат первога yield "2+2=?". На этой точке '
+'генератор приостанавлявает выполение.</li>'
+'<li>Затем, как показано на кортинке, результат yield переходит во внешний код '
+'в переменную question.</li>'
+'<li>При generator.next(8) выполннение генаратора возобнавляется, а 8 выходит '
+'из присваивания как результат let result=8.</li>'
+'<img src="img/genkod.png"><b>картинка</b></img>'
+'<br><i>//Генаратор можно остановить и возвратить через промежуток времени</i><br>'
+'settimeout(()=>generator.next(8),1000);'
+'</ol></li><li><i>Вот ещё пример с более, чем одним вызовом</i><br>'
+'function* gen(){<br>'
	+'let ask1=yield "2+2=?";<br>'
	+'alert(ask1); <i>//2+2=?</i><br>'
	+'let ask2=yield "3*3=?"<br>'
	+'alert(ask2); <i>//3*3=?</i><br>'
+'}<br>'
+'let generator = gen();<br>'
+'alert(generator.next().value); <i>//4</i><br>'
+'alert(generator.next(4).value); <i>// 9</i><br>'
+'alert(generator.next(9).done); <i>// true</i><br>'
+'<ol><a>Забацаем картинку и пояcним в натуре</a><br>'
+'<img src="img/yto.png"><b>выполнение генератора</b></img>'
+'<li>Первый .next() начинает выполнение... Оно доходит до первого yield.</li>'
+'<li>Результат возвращается во внешний код</li>'
+'<li>Второй .next(4) передаёт 4 обратно в генератор как результат первога yield и '
+'возобнавляет выполнение.</li>'
+'<li>...Оно доходит до второго yield, который станет резульатом .next(4).</li>'
+'<li>Третий next(9) передаёт 9 в генератор как результат второго yield и '
+'возобнавляет выполение, которое завершается окончанием функции: '
+'done: true, как следствие</li>'
+'Проще говоря, значение пинается всеми<br>'
+'</ol></li><li><i>А тут пропишем ошибку</i><br>'
+'function* gen(){<br>'
	+'try{<br>'
		+'let result=yield"2+2=?";<br>'
		+'alert("До этой строки не дойдём из-за исключения");<br>'
	+'}catch(e){<br>'
	+'	alert(e); <i>//ничего не показала, ведь мы ничего и не требовали</i><br>'
+'}}<br>'
+'let generator=gen();<br>'
+'let question=generator.next().value;<br>'
+'generator.throw(new Error("No such answer")); <i>//Error: No such answer</i></li><li><br>'
+'<i>Но отловить её мы можем</i><br>'
+'function* generate(){<br>'
	+'let result=yield"2*2=?"; <i>//Error hier</i><br>'
+'}<br>'
+'let generator=generate();<br>'
+'let question=generator.next().value;<br>'
+'try{<br>'
	+'generator.throw(new Error("No such answer"));<br>'
	+'}catch(e){<br>'
		+'alert(e);<br>'
	+'} <i>//Error: No such answer (чё доказали, не понял)</i><br>'
	+'<i>//ошибка будет искаться, пока не упадёт скрипт</i><br></li><li>'
	+'<ul>'
	+'<li>&ensp;Генараторы создаются при помощи функций-генераторов function* f(...){...}</li>'
	+'<li>&ensp;Внутри генараторов и только внутри них существует оператор yield.</li>'
	+'<li>&ensp;Внешний код и генератор обмениваются промежуточными рузультатами посредством '
	+'вызовов next/yield.</li></ul>'
+'</li></ul><li>'
+'<b>Псевдослучайный генератор</b><br>'
+'function* pseudoRandom(seed){<br>'
	+'let value=seed;<br>'
	+'while(true){<br>'
		+'value=value*168%214748<br>'
		+'yield value;<br>'
+'}}; <br>'
+'let generator=pseudoRandom(1);<br>'
+'alert(generator.next().value); <i>//168</i><br>'
+'alert(generator.next().value); <i>//28224</i><br>'
+'alert(generator.next().value); <i>//17176</i><br>'
+'</li><ol><b>Асинхронные итераторы и генераторы</b><br>'
+'<li><i>Асинхронные итераторы</i><br>'
+'Выглядит эта муть следующим образом:<br>'
+'let range={<br>'
	+'from: 6,<br>'
	+'to: 9,<br>'
	+'[Symbol.iterator](){<br>'
		+'<i>//возращает объект-итератор:</i><br>'
		+'<i>//далее for...of работает только с этим объектом</i><br>'
		+'return{<br>'
			+'current:this.from,<br>'
			+'last:this.to,<br>'
			+'<i>//next()вызывается на каждой итерации</i><br>'
			+'next(){ <i>//(2)</i><br>'
			+'<i>//должно быть значнеие в виде объекта</i><br>'
			+'if(this.current<=this.last){<br>'
			+'	return{done: false,value: this.current++}<br>'
		+'	}else{<br>'
	+'			return{done:true};<br>'
+'}}};}};<br>'
+'for(let value of range){<br>'
	+'alert(value); <i>//6...7...8...9(всё правильно)</i><br>'
+'}<br><ol><i>сделаем объект асинхронно итерируемым:</i><br>'
+'<li>Используется Symbol.asyncIterator вместо Symbol.iterator</li>'
+'<li>next() должен возвращать промис</li>'
+'<li>Чтобы перебрать такой объект, используется цикл for await(let item of iterable).<br>'
+'let range={<br>'
	+'from: 6,<br>'
	+'to: 9,<br>'
	+'<i>//for await...of вызвывает метод единожды</i><br>'
	+'[Symbol.asyncIterator](){ <i>//(1) - вызов выполняется первым</i><br>'
	+'<i>//возвращает объект-итератор:</i><br>'
	+'<i>//далее for await..of работает только с этим объектом</i><br>'
	+'<i>//next - следующее значение</i><br>'
+'	return {<br>'
		+'current:this.from,<br>'
		+'last:this.to,<br>'
		+'<i>//next() вызывается при каждой итерации</i><br>'
		+'async next(){ //(2)</i><br>'
		+'<i>//превращается в промис автоматически</i><br>'
		+'<i>//await для асинхронности</i><br>'
		+'await new Promise(resolve=>setTimeout(resolve,1000)); //(3)(не обязательна)</i><br>'
		+'if(this.current<=this.last){<br>'
			+'return{done:false,value:this.current++};<br>'
		+'}else{<br>'
	+'		return{done:true};<br>'
+'}}};}};<br>'
+'(async()=>{<br>'
	+'for await(let value of range){ <i>//(4) - вывод всей кухни</i><br>'
	  +' alert(value); <i>//6,7,8,9(интервал - одна секунда)</i><br>'
	+'   <i>//без интервала - всё быстро и по порядку</i><br>'
+'}})()</li><br>'
+'</ol><ol><a>Структура похожа на обычные итераторы</a><br>'
+'<li>Чтобы сдлеать объект асинхронно итерируемым, он должен иметь метод '
+'Symbol.asyncIterator</li>'
+'<li>Этот метод должен возвращать объект с методом next(), который '
+'в свою очередь возвращает промис</li>'
+'<li>Метод next() не обязательно должен быть async, он может быть обычным, '
+'возвращающим промис, но async позволяет использовать awaiat, а это удобно. '
+'Тут просто делаем на 1 секунду паузу</li>'
+'<li>Для итерации мы используем for await(let value of range), добавляя await '
+'после for. Он вызовет range[Symbol.asyncIterator]()всего один раз, а затем '
+'next() для получения значения</li>'
+'<table border="1"><a>Шпора</a><br>'
+'<tr><td></td><td>Итераторы</td><td>Асинхронные итераторы</td></tr>'
+'<tr><td style="font-size:14px">метод для создания итерируемого объекта</td><td>'
+'Symbol.iterator</td><td>Symbol.asyncIterator</td></tr>'
+'<tr><td style="font-size:14px">next() возвращает</td><td>Любое значение</td><td>промис</td></tr>'
+'<tr><td style="font-size:14px">Для цикла используйте</td><td>for...of</td>'
+'<td>for await...of</td></tr>'
+'</table></ol></li><li>'
+'<i>Асинхронные генераторы</i><br>'
+'function* generateSequence(start,end){<br>'
	+'for(let i=start;i<=end;i++){<br>'
	+'	yield i;<br>'
+'}}<br>'
+'for(let value of generateSequence(5,8)){<br>'
	+'alert(value); <i>//5,6,7,8 (только цифры)</i><br>'
+'}<br>'
+'<i>При добавлении в начало async</i><br>'
+'async function* generateSequence(start,end){<br>'
	+'for(let i=start;i<=end;i++){<br>'
		+'<i>//await возможен</i><br>'
		+'await new Promise(resolve=>setTimeout(resolve,1000));<br>'
	+'	yield i;<br>'
+'}}<br>'
+'(async()=>{<br>'
	+'let generator=generateSequence(1,5);<br>'
	+'for await(let value of generator){<br>'
	+'	alert(value); <i>//1,2,3,4,5 (задержки есть)</i><br>'
+'}})();<br>'
+'<i>Вот, как ещё можно:</i><br>'
+'result=await generator.next(); <i>//код ещё перед этим нужен наверное</i><br>'
+'</li></ol><li>'
+'<a>Асинхронно перебираемые объекты</a> +Symbol.iterator.<br>'
+'let range={<br>'
	+'from: 11,<br>'
	+'to: 15,<br>'
	+'*[Symbol.iterator](){ <i>//сокращение</i><br>'
	  +'for(let value=this.from;value<=this.to;value++){<br>'
		+'  yield value;<br>'
+'}}};<br>'
+'for(let value of range){<br>'
	+'alert(value); <i>//11,12,13,14,15 (без интервалов,пойдёт)</i><br>'
+'}<br>'
+'<i>асинхронный Symbol.asincIterator (asinc!):</i><br>'
+'let range={<br>'
+'from: 11,<br>'
+'to: 15,<br>'
+'async*[Symbol.asyncIterator](){<br>'
	+'for(let value=this.from;value<=this.to;value++){<br>'
		+'<i>//выделываем паузу</i><br>'
		+'await new Promise(resolve=>setTimeout(resolve,1000));<br>'
		+'yield value;<br>'
+'}}};<br>'
+'(async()=>{<br>'
	+'for await(let value of range){<br>'
		+'alert(value); <i>//кучей выводим</i><br>'
+'}})(); <i>//11,12,13,14,15 - с задержками, как полагается</i><br>'
+'"use strict"<br>'
+'async function* fetchCommits(repo){<br>'
	+'let url=`https://api.github.com/repos/${repo}/commits`;<br>'
	+'while(url){<br>'
		+'const response=await fetch(url,{ <i>//(1)</i><br>'
		  +'headers:{"User-Agent":"Our script"}, <i>//GitHub требует заголовок</i><br>'
		+'});<br>'
		+'const body=await response.json(); <i>//(2) ответ в формате json</i><br>'
		+'<i>//(3) Ссылку на следующую страницу видим в заголовке</i><br>'
		+'let nextPage=response.headers.get("Link").match(/<(.*?)>; rel="next"/);<br>'
		+'nextPage=nextPage && nextPage[1];<br>'
		+'url=nextPage;<br>'
		+'for(let commit of body){ <i>//(4) вернуть коммиты один за другим</i><br>'
	+'	   yield commit;<br>'
+'}}}<br>'
+'<ol><i>Сейчас я по порядку всё объясню</i><br>'
+'<li>Мы используем метод fetch браузера для загрузки с удалённго URL. '
+'Он возволяет при енобходимости добавлять авторизацию и другие заголовки, '
+'тут GitHub требует User-Agent.</li>'
+'<li>Результат fetch обрабатывается как JSON, это опять-таки метод, присущий fetch</li>'
+'<li>надо получить URL следующей страницы из заголовка ответа Link. Он имеет '
+'специальный формат, поэтому мы используем регулярное выражение. URL следующей '
+'страницы может выглядеть как https://api.github.com/repositories/93253246/'
+'commits?page=2, он генерируется самим GitHub.</li>'
+'<li>Затем мы выдаём все полученные коммиты, а когда они закончатся - сработает '
+'следущая итерация while(url), которая сделает ещё один запрос.</li>'
+'</ol><a>Пример:</a><br>'
+'async function* fetchCommits(repo) {<br>'
  +'let url = `https://api.github.com/repos/${repo}/commits`;<br>'
  +'while (url) {<br>'
    +'const response = await fetch(url, { <i>// (1)</i><br>'
      +'headers: {`User-Agent`: `Our script`}, <i>// GitHub требует заголовок user-agent</i><br>'
    +'});<br>'
    +'const body = await response.json(); <i>// (2) ответ в формате JSON (массив коммитов)</i><br>'
   +'<i> // (3) Ссылка на следующую страницу находится в заголовках, извлекаем её</i><br>'
    +'let nextPage = response.headers.get(`Link`).match(/<(.*?)>; rel="next"/);<br>'
    +'nextPage = nextPage && nextPage[1];<br>'
    +'url = nextPage;<br>'
    +'for(let commit of body) { <i>// (4) вернуть коммиты один за другим, до окончания страницы</i><br>'
    +'  yield commit;<br>'
  +'  }}}<br>'
+'(async()=>{<br>'
	+'let count=0;<br>'
	+'for await(const commit of fetchCommits(`javascript-tutorial/en.javascript.info`)){<br>'
		+'console.log(commit.author.login);<br>'
		+'if(++count==100){ <i>//100 commits</i><br>'
		+'   break;<br>'
	+'}}<br>'
+'})();<br>'
+'<i>В консоль загрузил кучу имён иностранными буквами</i><br>'	
+'</li></td></table>'

document.write(nach)+papi+prom;